#+title: "Machinery design"
#+startup: indent inlineimages latexpreview

* Design for *machinegun*

Public API modules are:

- ~machinery~ for startiing and calling machine controller
- ~machinery_utils~ for helpers and configuration
- ~machinery_mg_backend~ for setting up backend specific environment and components
- ~machinery_mg_schema~ for implementing namespace-specific thrift marshalling
- ~machinery_mg_schema_generic~ for base thrift  marshalling implementation

** General flow of a machine call (or signal)

*** Calls ~machinery~ function

For example ~machinery:start(NS, ID, Args, Backend)~.

**** Calls ~machinery_mg_backend~ callback function

Actual implementation involving transport and marshalling.

***** Machinegun processes request via http and thrift

****** During handling it calls according processor endpoint

*** Service *processor endpoint* handles request

Since http route is mapped to appropriate erlang module implementing ~machinery~ callbacks, this request then is passed to it with all required options.

**** Calls ~machinery_mg_backend:handle_function/4~

**** Calls ~machinery_mg_backend:dispatch_call/4~ or ~machinery_mg_backend:dispatch_signal/4~

***** This call is translated to ~machinery:dispatch_signal/4~ or ~machinery:dispatch_call/4~ or ~machinery:dispatch_repair/4~

* Design for *progressor*

** General flow

*** Calls ~machinery~ function

**** Calls ~machinery_prg_backend~ callback function

***** ??? PROFIT

Backend options must contain namespace mapping to resolve appropriate machinery-callback module.

*** Call mapped callback module
